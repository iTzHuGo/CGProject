/* ===================================================================================
	Departamento Eng. Informatica - FCTUC
	Computacao Grafica - 2022/23
	................................................ 
	Meta1- Project CG
	by: Ricardo Santiago
		2020219352
======================================================================================= */




#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <GL/glut.h>
#include <windows.h>

#include "RgbImage.h"
#define PI		 3.14159

//--------------------------------- Definir cores
#define BLUE     0.0, 0.0, 1.0
#define RED      1.0, 0.0, 0.0
#define YELLOW	 1.0, 1.0, 0.0
#define GREEN    0.0, 1.0, 0.0
#define ORANGE   1.0, 0.5, 0.1
#define CYAN     0.0, 1.0, 1.0
#define WHITE    1.0, 1.0, 1.0
#define BLACK    0.0, 0.0, 0.0
#define GRAY     0.3, 0.3, 0.3
#define MIDBLUE	0.0,0.0,0.60
#define COPER	0.72,0.45,0.2
//vidros
#define TURQUOISE 0.678431,0.917647 , 0.917647
#define NEONPINK 1.00,0.43,0.73
#define QUARTZ 0.85,0.85,0.95
#define YELLOWGREEN 0.6 ,0.8 ,0.196078
#define OldGold  0.81 , 0.71 ,0.23
#define Orchid  0.858824 ,0.439216 ,0.858824
#define Maroon 0.556863 , 0.137255, 0.419608
#define IndianRed 0.309804 , 0.184314 , 0.184314
#define Khaki   0.623529 ,0.623529, 0.372549
#define DarkOliveGreen   0.309804, 0.309804 , 0.184314
#define DarkOrchid	0.6, 0.196078 , 0.8
#define DarkSlateBlue  0.419608 , 0.137255 , 0.556863
#define DarkSlateGray  0.184314 , 0.309804 , 0.309804
#define DarkSlateGrey  0.184314 , 0.309804 , 0.309804
#define DarkTurquoise   0.439216 , 0.576471 , 0.858824
#define DimGrey  0.329412, 0.329412, 0.329412

//================================================================================
//------------------------------------------------------------ Sistema Coordenadas 

GLint		wScreen = 700, hScreen = 600;		//.. janela - pixeis
GLfloat		size = 10.0;	//.. Mundo  SIZE=coordenadas x=y=z

bool troca = 0;
//=================================================================== TEXTURAS
RgbImage imag;
//------------------------------------------------------------ Texturas (2 texturas)
GLuint   texture[3];

// ======================================================== Malha de poligonos
GLint dim = 256;
GLfloat med_dim = (float)dim / 2;
GLint i = 0;
GLint j = 0;



//========================================================= Animacao 



GLfloat	  rotacao = 0;
GLfloat   agRodas = 0;
GLfloat	  incRodas = 0;
GLint     sempreRodar = 0;

//controla a subida do carro
GLfloat   altura = 0;
GLfloat   incALT = 0.1;

//controla a transalação do carro
GLfloat	  centrox = 0;
GLfloat	  incX = 0.1;

//controla a translação do vidro
GLfloat vidroy = 0; 
GLfloat incVidro = 0.1;

//controla o zoom
GLint zoom = 85;




//============================================================= Observador
GLfloat  rVisao = 8, aVisao = -0.5 * PI, incVisao = 1;
GLfloat  obsP[] = { rVisao * cos(aVisao), 2.0, rVisao * sin(aVisao) };
float	 anguloZ = 35;


//===========================================================Variaveis e constantes
GLint     msec = 50;

//------------------------------------------------- Propriedades Materiais
void initMaterials(int material);

//---------------------------------------------------- AMBIENTE - fixa
GLint   Dia = 0;     //:::   'D'  
GLfloat intensidadeDia = 0.5;
GLfloat luzGlobalCorAmb[4] = { intensidadeDia, intensidadeDia,intensidadeDia, 1.0 };   // 

//---------------------------------------------------- Luz pontual no TETO (eixo Y)
GLint   ligaTeto = 1;		 //:::   'T'  
GLfloat intensidadeT = 0.05;  //:::   'I'  
GLint   luzR = 1;		 	 //:::   'R'  
GLint   luzG = 1;			 //:::   'G'  
GLint   luzB = 1;			 //:::   'B'  
GLfloat localPos[4] = { 0.0, 6.0, 0.0, 1.0 };
GLfloat localCorAmb[4] = { 0, 0, 0, 0.0 };
GLfloat localCorDif[4] = { luzR, luzG, luzB, 1.0 };
GLfloat localCorEsp[4] = { luzR, luzG, luzB, 1.0 };
// ================================================= Luz Foco
GLfloat Foco_direccao[] = { 1,-1, 0, 0 }; //……… x
GLfloat Foco1_cor[] = { 1, 0, 0, 1 }; //……… Cor da luz 1
GLfloat Foco_ak = 0.05;
GLfloat Foco_al = 0.00f;
GLfloat Foco_aq = 0.0f;
GLfloat Foco_Expon = 10;
GLfloat aberturaFoco = 90;
GLfloat Pos1[] = { 4, -1, 0,1 };




//=========================================== Objecto
GLint     material = 10;



//==================================================================== VERTEX ARAY
//------------------------------------------- coordenadas + normais + cores
GLfloat tam = 0.6;
static GLfloat vertices_base[] = {
	//…………………………………………………………………………………………………… x=tam (Esquerda)
		-tam,  -tam,  tam,	// 0 
		-tam,   tam,  tam,	// 1 
		-tam,   tam, -tam,	// 2 
		-tam,  -tam, -tam,	// 3 
		//…………………………………………………… Direita
		tam,  -tam,  tam,	// 4 
		tam,   tam,  tam,	// 5 
		tam,   tam, -tam,	// 6 
		tam,  -tam, -tam,	// 7 
		//……………………………………………………… Cima
		-tam,  tam,  tam,	// 8 
		-tam,  tam, -tam,	// 9 
		tam,  tam, -tam,// 10 
		tam,  tam,  tam,// 11 
		//……………………………………………………… Baixo
		-tam,  -tam,  tam,	// 12
		-tam,  -tam, -tam,	// 13
		tam,  -tam, -tam,	// 14
		tam,  -tam,  tam,	// 15 
		//……………………………………………………… Frente
		-tam,  -tam,  tam,	// 16
		-tam,   tam,  tam,	// 17
		tam,   tam,  tam,	// 18
		tam,  -tam,  tam,	// 19
		//……………………………………………………… Tras
		-tam,  -tam, -tam,	// 20
		-tam,   tam, -tam,	// 21
		tam,   tam, -tam,	// 22
		tam,  -tam, -tam,	// 23
};



static GLfloat normais[] = {
	//…………………………………………………………………………………………………… x=tam (Esquerda)
	  -1.0,  0.0,  0.0,
	  -1.0,  0.0,  0.0,
	  -1.0,  0.0,  0.0,
	  -1.0,  0.0,  0.0,
	  //…………………………………………………………………………………………………… x=tam (Direita)
	  1.0,  0.0,  0.0,
	  1.0,  0.0,  0.0,
	  1.0,  0.0,  0.0,
	  1.0,  0.0,  0.0,
	  //…………………………………………………………………………………………………… y=tam (Cima)
   0.0,  1.0,  0.0,
   0.0,  1.0,  0.0,
   0.0,  1.0,  0.0,
   0.0,  1.0,  0.0,
   //…………………………………………………………………………………………………… y=tam (Baixo)
	0.0,  -1.0,  0.0,
   0.0,  -1.0,  0.0,
   0.0,  -1.0,  0.0,
   0.0,  -1.0,  0.0,
   //…………………………………………………………………………………………………… z=tam (Frente)
   0.0,  0.0,  1.0,
   0.0,  0.0,  1.0,
   0.0,  0.0,  1.0,
   0.0,  0.0,  1.0,
   //…………………………………………………………………………………………………… z=tam (Tras)
   0.0,  0.0,  -1.0,
   0.0,  0.0,  -1.0,
   0.0,  0.0,  -1.0,
   0.0,  0.0,  -1.0,
};





//base
static GLuint     esquerda_base[] = { 0, 1, 2, 3 };
static GLuint     direita_base[] = { 4, 7, 6, 5 };

static GLuint     cima_base[] = { 8, 11, 10, 9 };
static GLuint	  baixo_base[] = { 12,13,14,15 };

static GLuint	  frente_base[] = { 16,19,18,17 };
static GLuint	  frente_base_dentro[] = { 16,17,18,19 };

static GLuint	  tras_base[] = { 20,23,22,21 };
static GLuint	  tras_base_dentro[] = { 20,21,22,23 };







//================================================================================
//=========================================================================== INIT

void initTexturas()
{


	//-----------------------------------------  Estrada
	glGenTextures(1, &texture[0]);
	glBindTexture(GL_TEXTURE_2D, texture[0]);
	imag.LoadBmpFile("road.bmp");
	glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
	glTexImage2D(GL_TEXTURE_2D, 0, 3,
		imag.GetNumCols(),
		imag.GetNumRows(), 0, GL_RGB, GL_UNSIGNED_BYTE,
		imag.ImageData());

	//-----------------------------------------  tras do carro
	glGenTextures(1, &texture[1]);
	glBindTexture(GL_TEXTURE_2D, texture[1]);
	glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
	imag.LoadBmpFile("driving.bmp");
	glTexImage2D(GL_TEXTURE_2D, 0, 3,
		imag.GetNumCols(),
		imag.GetNumRows(), 0, GL_RGB, GL_UNSIGNED_BYTE,
		imag.ImageData());



}

//…………………………………………………………………………………………………………………………………………… LUZES
void initLights(void) {
	//…………………………………………………………………………………………………………………………………………… Ambiente
	glLightModelfv(GL_LIGHT_MODEL_AMBIENT, luzGlobalCorAmb);

	//…………………………………………………………………………………………………………………………………………… Teto
	glLightfv(GL_LIGHT0, GL_POSITION, localPos);
	glLightfv(GL_LIGHT0, GL_AMBIENT, localCorAmb);
	glLightfv(GL_LIGHT0, GL_DIFFUSE, localCorDif);
	glLightfv(GL_LIGHT0, GL_SPECULAR, localCorEsp);


	//................................................ FOCO
	glLightfv(GL_LIGHT1, GL_POSITION, Pos1);
	glLightfv(GL_LIGHT1, GL_SPOT_DIRECTION, Foco_direccao);
	glLightf(GL_LIGHT1, GL_SPOT_CUTOFF, aberturaFoco); // abertura
	glLightf(GL_LIGHT1, GL_SPOT_EXPONENT, Foco_Expon); // concentração
	glLightfv(GL_LIGHT1, GL_DIFFUSE, Foco1_cor);
	glLightf(GL_LIGHT1, GL_CONSTANT_ATTENUATION, Foco_ak);
	glLightf(GL_LIGHT1, GL_LINEAR_ATTENUATION, Foco_al);
	glLightf(GL_LIGHT1, GL_QUADRATIC_ATTENUATION, Foco_aq);
}


void initialize(void)
{
	glClearColor(BLACK, 1);		//………………………………………………………………………………Apagar
	glShadeModel(GL_SMOOTH);    

	
	glEnable(GL_BLEND);
	glEnable(GL_DEPTH_TEST);	//………………………………………………………………………………Profundidade
	glEnable(GL_NORMALIZE);
	//…………………………………………………………………………………………………………………………… ILUMINACAO / MAteriais
	glEnable(GL_LIGHTING);
	glEnable(GL_LIGHT0);
	glEnable(GL_LIGHT1);

	initLights();
	initTexturas();
	glVertexPointer(3, GL_FLOAT, 0, vertices_base);	//………………………………………Posicoes
	glEnableClientState(GL_VERTEX_ARRAY);



	glNormalPointer(GL_FLOAT, 0, normais);		//………………………………………Normais
	glEnableClientState(GL_NORMAL_ARRAY);
	


	//initMaterials(10);   // gold



}




//======================================================================== ILUMINCCAO
void updateLuz() {
	localCorAmb[0] = luzR * intensidadeT;
	localCorAmb[1] = luzG * intensidadeT;
	localCorAmb[2] = luzB * intensidadeT;
	localCorDif[0] = luzR * intensidadeT;
	localCorDif[1] = luzG * intensidadeT;
	localCorDif[2] = luzB * intensidadeT;
	localCorEsp[0] = luzR * intensidadeT;
	localCorEsp[1] = luzG * intensidadeT;
	localCorEsp[2] = luzB * intensidadeT;


	glLightfv(GL_LIGHT0, GL_POSITION, localPos);
	glLightfv(GL_LIGHT0, GL_AMBIENT, localCorAmb);
	glLightfv(GL_LIGHT0, GL_DIFFUSE, localCorDif);
	glLightfv(GL_LIGHT0, GL_SPECULAR, localCorEsp);

	glLightfv(GL_LIGHT1, GL_POSITION, Pos1);
	glLightfv(GL_LIGHT1, GL_SPOT_DIRECTION, Foco_direccao);
	glLightf(GL_LIGHT1, GL_SPOT_CUTOFF, aberturaFoco); // abertura
	glLightf(GL_LIGHT1, GL_SPOT_EXPONENT, Foco_Expon); // concentração
	glLightfv(GL_LIGHT1, GL_DIFFUSE, Foco1_cor);
	glLightf(GL_LIGHT1, GL_CONSTANT_ATTENUATION, Foco_ak);
	glLightf(GL_LIGHT1, GL_LINEAR_ATTENUATION, Foco_al);
	glLightf(GL_LIGHT1, GL_QUADRATIC_ATTENUATION, Foco_aq);
}


void iluminacao() {
	updateLuz();
	if (ligaTeto)
		glEnable(GL_LIGHT0);
	else
		glDisable(GL_LIGHT0);
}


GLvoid resize(GLsizei width, GLsizei height) {
	wScreen = width;
	hScreen = height;
	glViewport(0, 0, wScreen, hScreen);
	glutPostRedisplay();
}


void drawEixos()
{
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Eixo
	glColor3f(ORANGE);
	glBegin(GL_LINES);
	glVertex3f(0, 0, 0);
	glVertex3f(0.5 * size, 0, 0);
	glEnd();
	glColor3f(GREEN);
	glBegin(GL_LINES);
	glVertex3f(0, 0, 0);
	glVertex3f(0, 0.5 * size, 0);
	glEnd();
	glColor3f(BLUE);
	glBegin(GL_LINES);
	glVertex3f(0, 0, 0);
	glVertex3f(0, 0, 0.5 * size);
	glEnd();

}

void desenha() {
	glPushMatrix();
	glDrawElements(GL_POLYGON, 4, GL_UNSIGNED_INT, cima_base);
	glPopMatrix();

	glPushMatrix();
	glDrawElements(GL_POLYGON, 4, GL_UNSIGNED_INT, baixo_base);
	glPopMatrix();

	glPushMatrix();
	glDrawElements(GL_POLYGON, 4, GL_UNSIGNED_INT, esquerda_base);
	glPopMatrix();

	glPushMatrix();
	glDrawElements(GL_POLYGON, 4, GL_UNSIGNED_INT, direita_base);
	glPopMatrix();

	glPushMatrix();
	glDrawElements(GL_POLYGON, 4, GL_UNSIGNED_INT, frente_base);
	glPopMatrix();

	glPushMatrix();
	glDrawElements(GL_POLYGON, 4, GL_UNSIGNED_INT, tras_base);
	glPopMatrix();

}

void desenha_vidro() {

	glPushMatrix();
	glDisable(GL_COLOR_MATERIAL);
	initMaterials(material);
	glDrawElements(GL_POLYGON, 4, GL_UNSIGNED_INT, cima_base);
	
	glEnable(GL_COLOR_MATERIAL);
	glColorMaterial(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE);

	glPopMatrix();

	glPushMatrix();
	glDrawElements(GL_POLYGON, 4, GL_UNSIGNED_INT, baixo_base);
	glPopMatrix();

	glPushMatrix();
	glDrawElements(GL_POLYGON, 4, GL_UNSIGNED_INT, esquerda_base);
	glPopMatrix();
	
	glDisable(GL_COLOR_MATERIAL);

	glPushMatrix();

	GLfloat  corDireita[] = { 1. ,1.,1.,1 };
	glMaterialfv(GL_FRONT, GL_AMBIENT, corDireita);
	glMaterialfv(GL_FRONT, GL_DIFFUSE, corDireita);
	glMaterialfv(GL_FRONT, GL_SPECULAR, corDireita);
	glMaterialf(GL_FRONT, GL_SHININESS, 0.5);

	glEnable(GL_TEXTURE_2D);
	glBindTexture(GL_TEXTURE_2D, texture[1]);
	glNormal3d(1, 0, 0);

	glBegin(GL_QUADS);
		glTexCoord2f(1.0f, 0.0f);
		glVertex3f(0.6, -0.6, 0.6);

		glTexCoord2f(0.0f, 0.0f);
		glVertex3f(0.6, -0.6, -0.6);

		glTexCoord2f(0.0f, 1.0f);
		glVertex3f(0.6, 0.6, -0.6);

		glTexCoord2f(1.0f, 1.0f);
		glVertex3f(0.6, 0.6, 0.6);

	glEnd();

	glDisable(GL_TEXTURE_2D);

	glPopMatrix();


	glEnable(GL_COLOR_MATERIAL);
	glColorMaterial(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE);

	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);


	glPushMatrix();

	glTranslatef(0.0, vidroy, 0.0); //este translate vai ser comum a todos

	glPushMatrix();
	glColor4f(TURQUOISE,0.6);
	glDrawElements(GL_POLYGON, 4, GL_UNSIGNED_INT, frente_base);
	glPopMatrix();


	glPushMatrix();
	glColor4f(TURQUOISE,0.6);
	glDrawElements(GL_POLYGON, 4, GL_UNSIGNED_INT, tras_base);
	glPopMatrix();


	glBlendFunc(GL_ONE, GL_ZERO);

	glPopMatrix();
}

void desenhaEstrada() {
	GLfloat  corEstrada[] = { 1. ,1.,1.,1 };
	glMaterialfv(GL_FRONT, GL_AMBIENT, corEstrada);
	glMaterialfv(GL_FRONT, GL_DIFFUSE, corEstrada);
	glMaterialfv(GL_FRONT, GL_SPECULAR, corEstrada);
	glMaterialf(GL_FRONT, GL_SHININESS, 0.5);

	glEnable(GL_TEXTURE_2D);
	glBindTexture(GL_TEXTURE_2D, texture[0]);
	glNormal3d(0, 1, 0);

	glPushMatrix();
	glTranslatef(-5, -1.9, 6);
	glScalef(10, 0, 5);
	glRotatef(90, 0, 1, 0);
	glRotatef(90, 1, 0, 0);
	glBegin(GL_QUADS);
	/*glTexCoord2f(0.0f, 0.0f);
	glVertex3f(-17, -1.8, 5.5);

	glTexCoord2f(0.0f, 1.0f);
	glVertex3f(17, -1.8, 5.5);

	glTexCoord2f(1.0f, 0.0f);
	glVertex3f(17, -1.8, -3);

	glTexCoord2f(1.0f, 1.0f);
	glVertex3f(-17, -1.8, -3);
	*/
	med_dim = (float)dim / 2;
	for ( i = 0; i < dim; i++)
		 for ( j = 0; j < dim; j++) {
		glTexCoord2f((float)j / dim, (float)i / dim);
		glVertex3d((float)j / med_dim, (float)i / med_dim, 0);
		glTexCoord2f((float)(j + 1) / dim, (float)i / dim);
		glVertex3d((float)(j + 1) / med_dim, (float)i / med_dim, 0);
		glTexCoord2f((float)(j + 1) / dim, (float)(i + 1) / dim);
		glVertex3d((float)(j + 1) / med_dim, (float)(i + 1) / med_dim, 0);
		glTexCoord2f((float)j / dim, (float)(i + 1) / dim);
		glVertex3d((float)j / med_dim, (float)(i + 1) / med_dim, 0);
	}
	glEnd();
	glPopMatrix();

	glDisable(GL_TEXTURE_2D);


}

//======================================
void drawScene() {
	glBlendFunc(GL_ONE, GL_ZERO);

	glEnable(GL_COLOR_MATERIAL);
	glColorMaterial(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE);

	//==================================== Esfera da luz (pontual)
	glPushMatrix();
	glTranslatef(0, 5, 0);
	glColor3f(YELLOW);
	glutSolidSphere(0.3, 40, 40);
	glPopMatrix();

	//==================================== Esfera da luz (FOCO)
	glPushMatrix();
	glTranslatef(4, -1, 0);
	glColor3f(YELLOW);
	glutSolidSphere(0.3, 40, 40);
	glPopMatrix();


	glColor3f(DimGrey);

	//==================================== Post de luz
	glPushMatrix();
	glTranslatef(0, 2.3, 4);
	glScalef(1, 6.5, 1);
	desenha();
	glPopMatrix();

	//==================================== Posta da luz 2
	glPushMatrix();
	glTranslatef(0, 5.6, 2);
	glScalef(1, 1, 4);
	desenha();
	glPopMatrix();

	glPushMatrix();
	
	
	
	//==================================== Base

	glTranslatef(centrox, altura, 0.0); //este translate vai ser comum a todos
	glColor3f (MIDBLUE);
	
	glPushMatrix();
	glScalef(4.5, 2.0, 2.5);
	desenha();
	glPopMatrix();

	//==================================== Superior
	glColor3f(WHITE);
	
	glPushMatrix();
	glTranslatef(0.0, 2.0, 0.0);
	glScalef(2.0, 2.0, 2.4);
	desenha_vidro();
	glPopMatrix();


	//==================================== rodas
	glColor3f(DimGrey);
	

	//roda esquerda 1
	glPushMatrix();
	glTranslatef(-1.8, -1.0, 1.25);
	glRotated(rotacao, 0, 0, 1);
	glScalef(1, 1, 1);
	desenha();
	glPopMatrix();

	//roda esquerda 2
	glPushMatrix();
	glTranslatef(-1.8, -1.0,- 1.25);
	glRotated(rotacao, 0, 0, 1);
	glScalef(1, 1, 1);
	desenha();
	glPopMatrix();

	//roda direita 1
	glPushMatrix();
	glTranslatef(1.8, -1.0, 1.25);
	glRotated(rotacao, 0, 0, 1);
	glScalef(1, 1, 1);
	desenha();
	glPopMatrix();

	//roda direita 2
	glPushMatrix();
	glTranslatef(1.8, -1.0, -1.25);
	glRotated(rotacao, 0, 0, 1);
	glScalef(1, 1, 1);
	desenha();
	glPopMatrix();
	
	glPopMatrix();


	

	glDisable(GL_COLOR_MATERIAL);
	//==================================== Estrada
	desenhaEstrada();



}




//====================================================== 
//====================================================== 
void display(void) {

	//================================================================= APaga 
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

	glEnable(GL_LIGHTING);
	//================================================================= Viewport 1
	//meter zoom
	
	glViewport(0, 0, wScreen, hScreen);
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	gluPerspective(zoom, (float)wScreen / hScreen, 0.1, 9999);

	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();

	
	gluLookAt(obsP[0], obsP[1], obsP[2], 0, 0, 0, 0, 1, 0);
	//======================================================
	iluminacao();

	//…………………………………………………………………………………………………………………………………………………………Objectos
	drawEixos();
	drawScene();

	//================================================================= Viewport 2
	//vista de cima
	//meeter zoom
	glViewport(0, 0, wScreen * 0.2, hScreen * 0.3);
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	gluPerspective(85, (float)wScreen / hScreen, 0.1, 100);

	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();

	
	gluLookAt(0, 15, 0, 0, 0, 0, 0, 0, 1);
	//======================================================
	iluminacao();
	//…………………………………………………………………………………………………………………………………………………………Objectos
	drawEixos();
	drawScene();





	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Actualizacao
	glutSwapBuffers();
}






//======================================================= EVENTOS
void keyboard(unsigned char key, int x, int y) {


	switch (key) {

	//case 'R': case 'r':
		//sempreRodar = !sempreRodar;
		//glutPostRedisplay();
		//break;

	//------------------------------ translacao	
	case 'A': case 'a':
		centrox = centrox + incX;
		if (centrox > 3) {
			incX = -incX;
		}
		if (centrox < -1) {
			incX = -incX;
		}
		glutPostRedisplay();
		break;
	case 'S': case 's':
		centrox = centrox - incX;
		if (centrox > 3) {
			incX = -incX;
		}
		if (centrox < -1) {
			incX = -incX;
		}
		glutPostRedisplay();
		break;
		//------------------------------ rotacao	
	case 'E': case 'e':
		rotacao = rotacao + 2.5;
		glutPostRedisplay();
		break;
	case 'D': case 'd':
		rotacao = rotacao - 2.5;
		glutPostRedisplay();
		break;
		//------------------------------ vidro
	case 'Q': case 'q':
		if (vidroy >= 0.0) {
			vidroy = 0.0;
			incVidro = -incVidro;
		}
		if (vidroy < -1.0) {
			vidroy =-1.0;
			incVidro = -incVidro;
		}
		vidroy = vidroy + incVidro;

		glutPostRedisplay();
		break;
	case '+': 
		if (zoom > 50) {
			zoom--;
		}
		glutPostRedisplay();
		break;
	case '-':
		if (zoom < 160) {
			zoom++;
		}
		glutPostRedisplay();
		break;


		//--------------------------- TETO
	case 't':case 'T':
		ligaTeto = !ligaTeto;
		updateLuz();
		glutPostRedisplay();
		break;
	
		//--------------------------- Iluminacaoda sala
	case 'i': case 'I':
		intensidadeT = intensidadeT + 0.1;
		if (intensidadeT > 1.1) intensidadeT = 0;
		updateLuz();
		glutPostRedisplay();
		break;
	case 'r':case 'R':
		luzR = (luzR + 1) % 2;
		updateLuz();
		glutPostRedisplay();
		break;
	case 'g':case 'G':
		luzG = (luzG + 1) % 2;
		updateLuz();
		glutPostRedisplay();
		break;
	case 'b':case 'B':
		luzB = (luzB + 1) % 2;
		updateLuz();
		glutPostRedisplay();
		break;

	//--------------------------- MAterial
	case 'm': case 'M':
		material = (material + 1) % 18;
		initMaterials(material);
		glutPostRedisplay();
		break;
	//______________________ divisão de poligonos
	case 'p': case 'P':
		dim = 2 * dim;
		if (dim > 256) dim = 10;
		glutPostRedisplay();
		break;


	case 27:
		exit(0);
		break;
	}

}



void teclasNotAscii(int key, int x, int y) {

	//=========================================================
	//  <><><><><><>  Movimento do observador  ???
	//=========================================================
	if (key == GLUT_KEY_UP) { // Movimento para cima
		obsP[1] += 0.2;
	}
	if (key == GLUT_KEY_DOWN) { // Movimento para baixo
		obsP[1] -= 0.2;
	}
	if (key == GLUT_KEY_LEFT) { // Movimento para a esquerda
		aVisao -= 0.2;
		obsP[0] = rVisao * cos(aVisao);
		obsP[2] = rVisao * sin(aVisao);
	}
	if (key == GLUT_KEY_RIGHT) { // Movimento para a direira
		aVisao += 0.2;
		obsP[0] = rVisao * cos(aVisao);
		obsP[2] = rVisao * sin(aVisao);
	}

	glutPostRedisplay();
}

void Timer(int value)
{
	glutPostRedisplay();
	glutTimerFunc(msec, Timer, 1);
}

//======================================================= MAIN
//======================================================= MAIN
int main(int argc, char** argv) {

	glutInit(&argc, argv);
	glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);
	glutInitWindowSize(wScreen, hScreen);
	glutInitWindowPosition(400, 100);
	glutCreateWindow("RicardoSantiago_2020219352 |Observador:'SETAS'| |Transalation:'s/S''a/A' Rotation:'r/R' Rodas:'e/E''d/D' Vidro:'q/Q' ZOOM:'+/-'  ");

	initialize();

	glutSpecialFunc(teclasNotAscii);
	glutDisplayFunc(display);
	glutKeyboardFunc(keyboard);
	glutTimerFunc(msec, Timer, 1);

	glutMainLoop();

	return 0;
}



